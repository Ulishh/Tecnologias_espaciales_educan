# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'educan.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.
import serial # Libreria para leer el serial
import time # Libreria para timers
import re  # Libreria para usar expresiones regulares
import numpy as np # Libreria para procesar datos
import sys 
from PyQt5.QtCore import QTimer
from PyQt5.QtWidgets import QApplication, QMainWindow, QPushButton, QVBoxLayout, QWidget, QLabel
from PyQt5.QtWidgets import QApplication, QTextEdit, QVBoxLayout, QWidget
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5 import QtCore, QtGui, QtWidgets
# Librerias para las graficas
import matplotlib.pyplot as plt
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        # Configurar comunicacion serial con Arduino
        self.serial_port = serial.Serial('COM14', 9600)  # Cambiar el puerto COM si es necesario
        time.sleep(2)  # Esperar a que el puerto serial se estabilice

        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1400, 800)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.textEdit = QtWidgets.QTextEdit(self.centralwidget)
        self.textEdit.setGeometry(QtCore.QRect(600, 20, 200, 80))
        self.textEdit.setReadOnly(True)
        self.textEdit.setObjectName("textEdit") 
        self.Datos_serial = QtWidgets.QTextEdit(self.centralwidget)
        self.Datos_serial.setGeometry(QtCore.QRect(50, 150, 300, 700))
        self.Datos_serial.setReadOnly(True)
        self.Datos_serial.setObjectName("datos_serial")

        # Espacio para la grafica de altitud
        self.graph_widget1 = QWidget(self.centralwidget)
        self.graph_widget1.setGeometry(QtCore.QRect(370, 150, 480, 300))
        self.graph_layout1 = QVBoxLayout(self.graph_widget1)
        # Se crea la figura para la grafica
        self.figure1 = plt.figure()
        self.canvas1 = FigureCanvas(self.figure1)
        self.graph_layout1.addWidget(self.canvas1)

        # Espacio para la grafica de altitud
        self.graph_widget2 = QWidget(self.centralwidget)
        self.graph_widget2.setGeometry(QtCore.QRect(870, 150, 500, 300))
        self.graph_layout2 = QVBoxLayout(self.graph_widget2)
        # Se crea la figura para la grafica
        self.figure2 = plt.figure()
        self.canvas2 = FigureCanvas(self.figure2)
        self.graph_layout2.addWidget(self.canvas2)

        # Espacio para la grafica de altitud
        self.graph_widget3 = QWidget(self.centralwidget)
        self.graph_widget3.setGeometry(QtCore.QRect(370, 480, 1000, 300))
        self.graph_layout3 = QVBoxLayout(self.graph_widget3)
        # Se crea la figura para la grafica
        self.figure3 = plt.figure()
        self.canvas3 = FigureCanvas(self.figure3)
        self.graph_layout3.addWidget(self.canvas3)

        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 800, 18))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

        # Se inicia un temporizador para leer datos del serial
        self.timer = QTimer()
        self.timer.timeout.connect(self.leer_serial)
        self.timer.start(100)  # Revisar cada 100 ms

        # Listas para almacenar los datos de tiempo (eje X) y los valores de los sensores (eje Y)
        self.tiempo_altitud = []
        self.tiempo_aceleracion = []
        self.tiempo_velocidad = []
        self.valores_altitud = []
        self.valores_aceleracion = []
        self.valores_velocidad = []

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.textEdit.setHtml(_translate("MainWindow", "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
"<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
"p, li { white-space: pre-wrap; }\n"
"</style></head><body style=\" font-family:\'MS Shell Dlg 2\'; font-size:8pt; font-weight:400; font-style:normal;\">\n"
"<p align=\"center\" style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:20pt; font-weight:600;\">Educan</span></p></body></html>"))



    # Funcion para leer datos del puerto serial, es decir, los datos que recibimos del satelite y que el arduino imprime por el serial
    def leer_serial(self):
        if self.serial_port.in_waiting > 0:  # Si hay datos disponibles
            # datos = self.serial_port.readline().decode('utf-8').strip()
            try:
                # Lee los datos del puerto serial y decodificalos
                datos = self.serial_port.read(self.serial_port.in_waiting).decode('utf-8').strip()
                self.Datos_serial.append(datos)  # Agregar los datos en el espacio de datos serial
                
                with open("educan.txt", "a") as archivo:
                    archivo.write(datos + "\n" + "\n")

                # Dividir los datos en lineas
                lineas = datos.splitlines()
                # Inicializar una lista para los matches
                matches = []
                # Extraer numeros de cada linea ya sean enteros o decimales
                cont = 0
                for linea in lineas:
                    matches = re.findall(r'[-+]?\d*\.\d+|\d+', linea)  # Agregar todos los matches
                    if cont == 2:
                        if len(matches) >= 1 and float(matches[0])>100.0:
                            valor_altitud = round(float(matches[0])) 
                            self.actualizar_grafica(valor_altitud,cont)
                    elif cont == 3:
                        if len(matches) >= 1:
                            valor_aceleracion = float(matches[0]) 
                            self.actualizar_grafica(valor_aceleracion,cont)
                    elif cont == 4:
                        if len(matches) >= 1:
                            valor_velocidad = float(matches[0]) 
                            self.actualizar_grafica(valor_velocidad,cont)
                    cont = cont+1
                # Solo se actualiza la grafica si se encuentran al menos un numero
                
                return datos
            except UnicodeDecodeError as e:
                # Maneja el error de decodificacion sin cerrar el programa
                print(f"Error de decodificacion: {e}")
                datos = ""
                return datos  # Opcional: retorna una cadena vacia o realiza otro tipo de manejo
                     
    # Funcion para actualizar la grafica
    def actualizar_grafica(self, y, tipo):
        if tipo == 2:
            self.tiempo_altitud.append(time.time())  # Agregar la marca de tiempo actual
            self.valores_altitud.append(y)  # Agregar el valor del sensor
            # Limpiar la figura y redibujar la grafica
            self.figure1.clear()
            ax = self.figure1.add_subplot(111)
            ax.plot(self.tiempo_altitud, self.valores_altitud, 'b-')
            ax.set_title("Altitud")
            ax.set_xlabel("Tiempo")
            ax.set_ylabel("Altitud")
            # Establecer limites de los ejes
            ax.set_xlim(min(self.tiempo_altitud) - 1, max(self.tiempo_altitud) + 1)  # Establece el limites del eje X
            ax.set_ylim(min(self.valores_altitud) - 1, max(self.valores_altitud) + 1)  # Establece el limites del eje Y
            # Ajustar la escala de tiempo
            ax.relim()
            ax.autoscale_view()
            self.canvas1.draw()
        if tipo == 3:
            self.tiempo_aceleracion.append(time.time())  # Agregar la marca de tiempo actual
            self.valores_aceleracion.append(y)  # Agregar el valor del sensor
            # Limpiar la figura y redibujar la grafica
            self.figure2.clear()
            ax = self.figure2.add_subplot(111)
            ax.plot(self.tiempo_aceleracion, self.valores_aceleracion, 'b-')
            ax.set_title("Aceleracion")
            ax.set_xlabel("Tiempo")
            ax.set_ylabel("Aceleracion")
            # Establecer limites de los ejes
            ax.set_xlim(min(self.tiempo_aceleracion) - 1, max(self.tiempo_aceleracion) + 1)  # Establece el limites del eje X
            ax.set_ylim(min(self.valores_aceleracion) - 1, max(self.valores_aceleracion) + 1)  # Establece el limites del eje Y
            # Ajustar la escala de tiempo
            ax.relim()
            ax.autoscale_view()
            self.canvas2.draw()
        if tipo == 4:
            self.tiempo_velocidad.append(time.time())  # Agregar la marca de tiempo actual
            self.valores_velocidad.append(y)  # Agregar el valor del sensor
            # Limpiar la figura y redibujar la grafica
            self.figure3.clear()
            ax = self.figure3.add_subplot(111)
            ax.plot(self.tiempo_velocidad, self.valores_velocidad, 'b-')
            ax.set_title("Velocidad")
            ax.set_xlabel("Tiempo")
            ax.set_ylabel("Velocidad")
            # Establecer limites de los ejes
            ax.set_xlim(min(self.tiempo_velocidad) - 1, max(self.tiempo_velocidad) + 1)  # Establece el limites del eje X
            ax.set_ylim(min(self.valores_velocidad) - 1, max(self.valores_velocidad) + 1)  # Establece el limites del eje Y
            # Ajustar la escala de tiempo
            ax.relim()
            ax.autoscale_view()
            self.canvas3.draw()

    # Cerrar el puerto serial cuando se cierre la aplicacion
    def closeEvent(self, event):
        self.serial_port.close()
        event.accept()


if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())
